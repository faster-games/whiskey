
// <auto-generated>
// This code was generated by a tool. Any changes made manually will be lost
// the next time this code is regenerated.
// </auto-generated>

using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace FasterGames.Whiskey
{
    /// <summary>
    /// Provides a read only value accessor
    /// </summary>
    /// <typeparam name="TValue">type of value</typeparam>
    public interface IReadOnlyValue<TValue>
    {
        /// <summary>
        /// Accesses a read only value
        /// </summary>
        public TValue ReadOnlyValue
        {
            get;
        }
    }

    /// <summary>
    /// Provides read/write value accessors
    /// </summary>
    /// <typeparam name="TValue">type of value</typeparam>
    public interface IReadWriteValue<TValue> : IReadOnlyValue<TValue>
    {
        /// <summary>
        /// Accesses a read/write value
        /// </summary>
        public TValue Value
        {
            get;
            set;
        }
    }
    
    /// <summary>
    /// Abstract <see cref="ScriptableObject"/> wrapper for immutable objects
    /// </summary>
    /// <typeparam name="TObject">type of object</typeparam>
    [Serializable]
    public abstract class ImmutableObject<TObject> : ScriptableObject, IReadOnlyValue<TObject>
    {
        /// <inheritdoc />
        public abstract TObject ReadOnlyValue
        {
            get;
        }
    }

    /// <summary>
    /// Abstract <see cref="ScriptableObject"/> wrapper for mutable objects
    /// </summary>
    /// <typeparam name="TObject">type of object</typeparam>
    [Serializable]
    public abstract class MutableObject<TObject> : ImmutableObject<TObject>, IReadWriteValue<TObject>
    {
        /// <inheritdoc />
        public abstract TObject Value
        {
            get;
            set;
        }
    }

    /// <summary>
    /// Abstract probability table for immutable objects
    /// </summary>
    /// <typeparam name="TObject">type of object</typeparam>
    [Serializable]
    public abstract class ImmutableDataTable<TObject> : ImmutableObject<TObject>
    {
        /// <summary>
        /// Represents an entry in the probability table
        /// </summary>
        [Serializable]
        public class ImmutableObjectTableEntry
        {
            /// <summary>
            /// The weight of the object
            /// </summary>
            public float Weight = 1f;
            
            /// <summary>
            /// The value of the object
            /// </summary>
            public TObject Value;

            /// <summary>
            /// Editor preview of the object change
            /// </summary>
            [ReadOnly]
            internal float Chance;
            
            /// <summary>
            /// The entry low bound
            /// </summary>
            internal float LowBound { get; set; }
            
            /// <summary>
            /// The entry high bound
            /// </summary>
            internal float HighBound { get; set; }
        }

        /// <summary>
        /// The object entries
        /// </summary>
        public List<ImmutableObjectTableEntry> TableEntries = new List<ImmutableObjectTableEntry>();

        /// <summary>
        /// Editor preview of the weight in the table
        /// </summary>
        [ReadOnly]
        [SerializeField]
        protected float TotalWeightInTable;

        /// <summary>
        /// Editor preview of the dirty state flag
        /// </summary>
        [ReadOnly]
        [SerializeField]
        protected bool IsDirty = true;

        /// <inheritdoc />
        public override TObject ReadOnlyValue
        {
            get
            {
                if (TableEntries == null || TableEntries.Count == 0)
                {
                    return default(TObject);
                }

                if (IsDirty)
                {
                    Recalculate();
                }

                var rng = UnityEngine.Random.Range(0, TotalWeightInTable);

                foreach (var entry in TableEntries)
                {
                    if (rng > entry.LowBound && rng < entry.HighBound)
                    {
                        return entry.Value;
                    }
                }

                return default(TObject);
            }
        }

        /// <summary>
        /// Editor hook for calculating the table
        /// </summary>
        private void OnValidate()
        {
            Recalculate();
        }

        /// <summary>
        /// Internal calculation method
        /// </summary>
        private void Recalculate()
        {
            if (TableEntries == null || TableEntries.Count == 0)
            {
                return;
            }

            var maxWeight = 0f;

            foreach (var entry in TableEntries)
            {
                if (entry.Weight >= 0f)
                {
                    entry.LowBound = maxWeight;
                    maxWeight += entry.Weight;
                    entry.HighBound = maxWeight;
                }
                else
                {
                    entry.Weight = 0f;
                }
            }

            TotalWeightInTable = maxWeight;

            foreach (var entry in TableEntries)
            {
                entry.Chance = (entry.Weight / TotalWeightInTable) * 100;
            }
            
            IsDirty = false;
        }
    }

    /// <summary>
    /// Abstract reference to an immutable object
    /// </summary>
    /// <typeparam name="TObject">type of object</typeparam>
    [Serializable]
    public abstract class RefImmutable<TObject> : IReadOnlyValue<TObject>
    {
        /// <summary>
        /// Flag indicating if this reference points at a constant or an object
        /// </summary>
        [SerializeField]
        protected bool UseConstant = true;

        /// <summary>
        /// Constant value
        /// </summary>
        [SerializeField]
        protected TObject Constant;

        /// <summary>
        /// Object value
        /// </summary>
        [SerializeField]
        protected ImmutableObject<TObject> Object;
        
        /// <inheritdoc />
        public TObject ReadOnlyValue
        {
            get => UseConstant ? Constant : Object.ReadOnlyValue;
        }

        /// <summary>
        /// Raw operator
        /// </summary>
        /// <remarks>
        /// Allows us to treat the instance as if it's TRaw type for data access
        /// </remarks>
        /// <param name="reference">the reference to operate on</param>
        public static implicit operator TObject(RefImmutable<TObject> reference)
        {
            return reference.ReadOnlyValue;
        }
    }

    /// <summary>
    /// Abstract reference to a mutable object
    /// </summary>
    /// <typeparam name="TObject">type of object</typeparam>
    [Serializable]
    public abstract class RefMutable<TObject> : IReadWriteValue<TObject>
    {
        /// <summary>
        /// Flag indicating if this reference points at a constant or an object
        /// </summary>
        [SerializeField]
        protected bool UseConstant = true;

        /// <summary>
        /// Constant value
        /// </summary>
        [SerializeField]
        protected TObject Constant;

        /// <summary>
        /// Object value
        /// </summary>
        [SerializeField]
        protected MutableObject<TObject> Object;
        
        /// <inheritdoc />
        public TObject ReadOnlyValue
        {
            get => UseConstant ? Constant : Object.ReadOnlyValue;
        }

        /// <inheritdoc />
        public TObject Value
        {
            get => UseConstant ? Constant : Object.ReadOnlyValue;
            set
            {
                if (UseConstant)
                {
                    Constant = value;
                }
                else
                {
                    Object.Value = value;
                }
            }
        }

        /// <summary>
        /// Raw operator
        /// </summary>
        /// <remarks>
        /// Allows us to treat the instance as if it's TRaw type for data access
        /// </remarks>
        /// <param name="reference">the reference to operate on</param>
        public static implicit operator TObject(RefMutable<TObject> reference)
        {
            return reference.Value;
        }
    }

}
