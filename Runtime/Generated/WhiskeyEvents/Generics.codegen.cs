
// <auto-generated>
// This code was generated by a tool. Any changes made manually will be lost
// the next time this code is regenerated.
// </auto-generated>

using System;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

namespace FasterGames.Whiskey
{
/// <summary>
/// Subscription provider for handlers.
/// </summary>
/// <typeparam name="THandler">type of handler</typeparam>
public interface ISubscriptionProvider<THandler>
{
    /// <summary>
    /// Count of subscribers.
    /// </summary>
    int Count { get; }

    /// <summary>
    /// Subscribes a handler to this provider.
    /// </summary>
    /// <param name="handler">handler to subscribe</param>
    void Subscribe(THandler handler);

    /// <summary>
    /// Unsubscribes a handler from this provider.
    /// </summary>
    /// <param name="handler">handler to unsubscribe</param>
    void Unsubscribe(THandler handler);
}


/// <summary>
/// Trigger with 0 parameter.
/// </summary>
public interface ITrigger<TArg0>
{
    /// <summary>
    /// Trigger with 0 parameter.
    /// </summary>
    void Trigger(TArg0 arg0);
}

/// <summary>
/// Handler with 0 argument.
/// </summary>
public interface IHandler<TArg0>
{
    /// <summary>
    /// Handle with 0 argument.
    /// </summary>
    void Handle(TArg0 arg0);
}

/// <summary>
/// ScriptableObject Base event with 0 argument.
/// </summary>
/// <remarks>
/// All 0 argument events should derive from this type.
/// </remarks>
/// <typeparam name="THandler">type of event handler</typeparam>
public abstract class BaseEvent<THandler, TArg0>: ScriptableObject, ITrigger<TArg0>, ISubscriptionProvider<THandler>
    where THandler : IHandler<TArg0>
{
    /// <inheritdoc/>
    public int Count { get { return Handlers.Count; } }

    /// <summary>
    /// List of handlers that BaseEvent adds and removes from.
    /// </summary>
    /// <remarks>
    /// As an event implementor, you must define the storage for this data.
    /// </remarks>
    public abstract List<THandler> Handlers { get; }

    /// <inheritdoc/>
    public void Subscribe(THandler handler) => Handlers.Add(handler);

    /// <inheritdoc/>
    public void Unsubscribe(THandler handler) => Handlers.Remove(handler);

    /// <inheritdoc/>
    public void Trigger(TArg0 arg0)
    {
        foreach (var handler in Handlers)
        {
            handler.Handle( arg0);
        }
    }
}

/// <summary>
/// MonoBehaviour Base listener with 0 argument.
/// </summary>
/// <remarks>
/// All 0 argument listeners should derive from this type.
/// </remarks>
/// <typeparam name="TEvent">type of event</typeparam>
/// <typeparam name="TReaction">type of reaction</typeparam>
public abstract class BaseListener<TEvent, TReaction, TArg0> : MonoBehaviour, IHandler<TArg0>
    where TReaction : UnityEvent<TArg0>
{
    /// <summary>
    /// Reaction that BaseListener invokes.
    /// </summary>
    /// <remarks>
    /// As a listener implementor, you must define the storage for this data.
    /// </remarks>
    public abstract TReaction Reaction { get; }

    /// <summary>
    /// Event that invokes the BaseListener.
    /// </summary>
    /// <remarks>
    /// As a listener implementor, you must define the storage for this data.
    /// </remarks>
    public abstract TEvent Event { get; set; }

    /// <inheritdoc/>
    public void Handle(TArg0 arg0)
    {
        Reaction.Invoke( arg0);
    }
}


/// <summary>
/// Trigger with 1 parameter.
/// </summary>
public interface ITrigger<TArg0, TArg1>
{
    /// <summary>
    /// Trigger with 1 parameter.
    /// </summary>
    void Trigger(TArg0 arg0, TArg1 arg1);
}

/// <summary>
/// Handler with 1 argument.
/// </summary>
public interface IHandler<TArg0, TArg1>
{
    /// <summary>
    /// Handle with 1 argument.
    /// </summary>
    void Handle(TArg0 arg0, TArg1 arg1);
}

/// <summary>
/// ScriptableObject Base event with 1 argument.
/// </summary>
/// <remarks>
/// All 1 argument events should derive from this type.
/// </remarks>
/// <typeparam name="THandler">type of event handler</typeparam>
public abstract class BaseEvent<THandler, TArg0, TArg1>: ScriptableObject, ITrigger<TArg0, TArg1>, ISubscriptionProvider<THandler>
    where THandler : IHandler<TArg0, TArg1>
{
    /// <inheritdoc/>
    public int Count { get { return Handlers.Count; } }

    /// <summary>
    /// List of handlers that BaseEvent adds and removes from.
    /// </summary>
    /// <remarks>
    /// As an event implementor, you must define the storage for this data.
    /// </remarks>
    public abstract List<THandler> Handlers { get; }

    /// <inheritdoc/>
    public void Subscribe(THandler handler) => Handlers.Add(handler);

    /// <inheritdoc/>
    public void Unsubscribe(THandler handler) => Handlers.Remove(handler);

    /// <inheritdoc/>
    public void Trigger(TArg0 arg0, TArg1 arg1)
    {
        foreach (var handler in Handlers)
        {
            handler.Handle( arg0,  arg1);
        }
    }
}

/// <summary>
/// MonoBehaviour Base listener with 1 argument.
/// </summary>
/// <remarks>
/// All 1 argument listeners should derive from this type.
/// </remarks>
/// <typeparam name="TEvent">type of event</typeparam>
/// <typeparam name="TReaction">type of reaction</typeparam>
public abstract class BaseListener<TEvent, TReaction, TArg0, TArg1> : MonoBehaviour, IHandler<TArg0, TArg1>
    where TReaction : UnityEvent<TArg0, TArg1>
{
    /// <summary>
    /// Reaction that BaseListener invokes.
    /// </summary>
    /// <remarks>
    /// As a listener implementor, you must define the storage for this data.
    /// </remarks>
    public abstract TReaction Reaction { get; }

    /// <summary>
    /// Event that invokes the BaseListener.
    /// </summary>
    /// <remarks>
    /// As a listener implementor, you must define the storage for this data.
    /// </remarks>
    public abstract TEvent Event { get; set; }

    /// <inheritdoc/>
    public void Handle(TArg0 arg0, TArg1 arg1)
    {
        Reaction.Invoke( arg0,  arg1);
    }
}


/// <summary>
/// Trigger with 2 parameter.
/// </summary>
public interface ITrigger<TArg0, TArg1, TArg2>
{
    /// <summary>
    /// Trigger with 2 parameter.
    /// </summary>
    void Trigger(TArg0 arg0, TArg1 arg1, TArg2 arg2);
}

/// <summary>
/// Handler with 2 argument.
/// </summary>
public interface IHandler<TArg0, TArg1, TArg2>
{
    /// <summary>
    /// Handle with 2 argument.
    /// </summary>
    void Handle(TArg0 arg0, TArg1 arg1, TArg2 arg2);
}

/// <summary>
/// ScriptableObject Base event with 2 argument.
/// </summary>
/// <remarks>
/// All 2 argument events should derive from this type.
/// </remarks>
/// <typeparam name="THandler">type of event handler</typeparam>
public abstract class BaseEvent<THandler, TArg0, TArg1, TArg2>: ScriptableObject, ITrigger<TArg0, TArg1, TArg2>, ISubscriptionProvider<THandler>
    where THandler : IHandler<TArg0, TArg1, TArg2>
{
    /// <inheritdoc/>
    public int Count { get { return Handlers.Count; } }

    /// <summary>
    /// List of handlers that BaseEvent adds and removes from.
    /// </summary>
    /// <remarks>
    /// As an event implementor, you must define the storage for this data.
    /// </remarks>
    public abstract List<THandler> Handlers { get; }

    /// <inheritdoc/>
    public void Subscribe(THandler handler) => Handlers.Add(handler);

    /// <inheritdoc/>
    public void Unsubscribe(THandler handler) => Handlers.Remove(handler);

    /// <inheritdoc/>
    public void Trigger(TArg0 arg0, TArg1 arg1, TArg2 arg2)
    {
        foreach (var handler in Handlers)
        {
            handler.Handle( arg0,  arg1,  arg2);
        }
    }
}

/// <summary>
/// MonoBehaviour Base listener with 2 argument.
/// </summary>
/// <remarks>
/// All 2 argument listeners should derive from this type.
/// </remarks>
/// <typeparam name="TEvent">type of event</typeparam>
/// <typeparam name="TReaction">type of reaction</typeparam>
public abstract class BaseListener<TEvent, TReaction, TArg0, TArg1, TArg2> : MonoBehaviour, IHandler<TArg0, TArg1, TArg2>
    where TReaction : UnityEvent<TArg0, TArg1, TArg2>
{
    /// <summary>
    /// Reaction that BaseListener invokes.
    /// </summary>
    /// <remarks>
    /// As a listener implementor, you must define the storage for this data.
    /// </remarks>
    public abstract TReaction Reaction { get; }

    /// <summary>
    /// Event that invokes the BaseListener.
    /// </summary>
    /// <remarks>
    /// As a listener implementor, you must define the storage for this data.
    /// </remarks>
    public abstract TEvent Event { get; set; }

    /// <inheritdoc/>
    public void Handle(TArg0 arg0, TArg1 arg1, TArg2 arg2)
    {
        Reaction.Invoke( arg0,  arg1,  arg2);
    }
}


/// <summary>
/// Trigger with 3 parameter.
/// </summary>
public interface ITrigger<TArg0, TArg1, TArg2, TArg3>
{
    /// <summary>
    /// Trigger with 3 parameter.
    /// </summary>
    void Trigger(TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3);
}

/// <summary>
/// Handler with 3 argument.
/// </summary>
public interface IHandler<TArg0, TArg1, TArg2, TArg3>
{
    /// <summary>
    /// Handle with 3 argument.
    /// </summary>
    void Handle(TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3);
}

/// <summary>
/// ScriptableObject Base event with 3 argument.
/// </summary>
/// <remarks>
/// All 3 argument events should derive from this type.
/// </remarks>
/// <typeparam name="THandler">type of event handler</typeparam>
public abstract class BaseEvent<THandler, TArg0, TArg1, TArg2, TArg3>: ScriptableObject, ITrigger<TArg0, TArg1, TArg2, TArg3>, ISubscriptionProvider<THandler>
    where THandler : IHandler<TArg0, TArg1, TArg2, TArg3>
{
    /// <inheritdoc/>
    public int Count { get { return Handlers.Count; } }

    /// <summary>
    /// List of handlers that BaseEvent adds and removes from.
    /// </summary>
    /// <remarks>
    /// As an event implementor, you must define the storage for this data.
    /// </remarks>
    public abstract List<THandler> Handlers { get; }

    /// <inheritdoc/>
    public void Subscribe(THandler handler) => Handlers.Add(handler);

    /// <inheritdoc/>
    public void Unsubscribe(THandler handler) => Handlers.Remove(handler);

    /// <inheritdoc/>
    public void Trigger(TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3)
    {
        foreach (var handler in Handlers)
        {
            handler.Handle( arg0,  arg1,  arg2,  arg3);
        }
    }
}

/// <summary>
/// MonoBehaviour Base listener with 3 argument.
/// </summary>
/// <remarks>
/// All 3 argument listeners should derive from this type.
/// </remarks>
/// <typeparam name="TEvent">type of event</typeparam>
/// <typeparam name="TReaction">type of reaction</typeparam>
public abstract class BaseListener<TEvent, TReaction, TArg0, TArg1, TArg2, TArg3> : MonoBehaviour, IHandler<TArg0, TArg1, TArg2, TArg3>
    where TReaction : UnityEvent<TArg0, TArg1, TArg2, TArg3>
{
    /// <summary>
    /// Reaction that BaseListener invokes.
    /// </summary>
    /// <remarks>
    /// As a listener implementor, you must define the storage for this data.
    /// </remarks>
    public abstract TReaction Reaction { get; }

    /// <summary>
    /// Event that invokes the BaseListener.
    /// </summary>
    /// <remarks>
    /// As a listener implementor, you must define the storage for this data.
    /// </remarks>
    public abstract TEvent Event { get; set; }

    /// <inheritdoc/>
    public void Handle(TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3)
    {
        Reaction.Invoke( arg0,  arg1,  arg2,  arg3);
    }
}


}
