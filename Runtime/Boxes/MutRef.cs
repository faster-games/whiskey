using System;
using System.Collections.Generic;
using FasterGames.Whiskey.PropertyAttributes;
using UnityEngine;
using Object = UnityEngine.Object;

namespace FasterGames.Whiskey.Boxes
{
    /// <summary>
    /// A <see cref="IReadable{T}"/> and <see cref="IWritable{T}"/> reference to some data of type {T}.
    /// </summary>
    /// <remarks>
    /// The data itself, may be direct (e.g. a constant) or indirect (e.g. inside a <see cref="Box{T}"/>)
    /// </remarks>
    /// <typeparam name="T">the referenced data type</typeparam>
    [Serializable]
    public class MutRef<T> : IEquatable<MutRef<T>>, IReadable<T>, IWritable<T>, IValueEquals<MutRef<T>>, IValueEquals<T>
    {
        public static class FieldNames
        {
            public static readonly string selector = nameof(MutRef<Object>.selector);
            public static readonly string box = nameof(MutRef<Object>.box);
            public static readonly string raw = nameof(MutRef<Object>.raw);
        }

        /// <summary>
        /// The selector determines which data type will be accessed.
        /// </summary>
        public enum Selector
        {
            /// <summary>
            /// Provides access directly - stores the value internally
            /// </summary>
            Direct,
            
            /// <summary>
            /// Provides access indirectly - stores reference to a box internally
            /// </summary>
            Boxed
        }

        /// <summary>
        /// The data type to store and access
        /// </summary>
        [SerializeField]
        protected Selector selector;
        
        /// <summary>
        /// Storage for raw data
        /// </summary>
        [SerializeField]
        protected T raw;
        
        /// <summary>
        /// Storage for boxed data
        /// </summary>
        [SerializeField]
        [GenericDrawer(ignoredNamespaces: new []{"FasterGames.Whiskey.Editor.Tests"})]
        protected Box<T> box;
        
        /// <summary>
        /// Element accessor
        /// </summary>
        /// <remarks>
        /// If the particular operation isn't supported (e.g. read-only) will throw
        /// </remarks>
        /// <exception cref="NotImplementedException">Invalid configuration - missing <see cref="Selector"/> value (development error).</exception>
        public T Value
        {
            get
            {
                switch (selector)
                {
                    case Selector.Direct:
                        return raw;
                    case Selector.Boxed:
                        return box.Read();
                    default:
                        throw new NotImplementedException();
                }
            }

            set
            {
                switch (selector)
                {
                    case Selector.Direct:
                        raw = value;
                        break;
                    case Selector.Boxed:
                        box.Write(value);
                        break;
                    default:
                        throw new NotImplementedException();
                }
            }
        }

        /// <inheritdoc />
        public T Read()
        {
            return Value;
        }

        /// <inheritdoc />
        public void Write(T value)
        {
            Value = value;
        }

        /// <inheritdoc />
        public bool ValueEquals(MutRef<T> other)
        {
            return EqualityComparer<T>.Default.Equals(Value, other.Value);
        }

        /// <inheritdoc />
        public bool ValueEquals(T other)
        {
            return EqualityComparer<T>.Default.Equals(Value, other);
        }

        /// <inheritdoc />
        public bool Equals(MutRef<T> other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;
            return selector == other.selector && EqualityComparer<T>.Default.Equals(raw, other.raw) && Equals(box, other.box);
        }

        /// <inheritdoc />
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            if (obj.GetType() != this.GetType()) return false;
            return Equals((MutRef<T>) obj);
        }

        /// <inheritdoc />
        public override int GetHashCode()
        {
            unchecked
            {
                // auto-generated by resharper
                var hashCode = (int) selector;
                hashCode = (hashCode * 397) ^ EqualityComparer<T>.Default.GetHashCode(raw);
                hashCode = (hashCode * 397) ^ (box != null ? box.GetHashCode() : 0);
                return hashCode;
            }
        }
    }
}